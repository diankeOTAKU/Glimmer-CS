# <center><font color=blue>微光招新题之计算机系统之内存模型</font></center>
## C语言内存模型
| 内存分区| 	具体含义  |  
|:--------:|:--------:|   
|程序代码区 (code)|存储了程序的可执行代码，通常是只读的|
|常量区 (constant)|存储了程序中定义的常量(如字符串、数字等),这些常量在程序运行期间是不可更改的|
|全局数据区 (global data)|存储了程序中定义的全局变量和静态变量|
|堆区 (heap)	|存储程序运行过程中动态创建的对象|
|动态链接库|包含了程序运行时需要的函数和数据|
|栈区 (stack)|用于存储函数调用信息和局部变量的内存区域|

### 1.什么是“栈溢出”？
**答：**
首先，我们要知道，计算机程序在运行时，使用了一个叫做“栈”的地方来存放临时数据。但是，如果不小心往栈里放了太多数据，超出了栈原本能够容纳的范围，就会发生“栈溢出”。这么说吧，假设咱们有一个固定大小的篮子（栈），用来放东西（数据）。每次放一个新东西进去，都要确保篮子里还有足够的空间。但如果咱一直不停地往里放东西，直到篮子装满了还继续放，那么东西就会从篮子里溢出来（栈溢出）。
### 2.堆区和栈区的区别是什么？
**答：**
|   | 栈区 | 堆区  |  
|:--------:|:--------:|:--------:|  
| 管理方式  |  编译器自动 | 程序猿手动 |  
| 空间大小  | 小  | 大 |    
|  使用场景 | 局部变量<br>数组<br>函数调用参数和返回值<br>...|  内存块<br>大型数据结构<br>...|
### 3.程序运行过程中，内存模型当中的哪些区是只读的，哪些区是可读写的？
**答：**
==**只读**==：
- 代码区
- 常量区

==**可读写**==：
- 已初始化读写数据区
- 未初始化读写数据区
- 栈区
- 堆区
### 4.如何使用malloc()、free()函数，它们针对的哪一个区进行操作？
**答：**
- malloc() 函数用于从堆区分配指定大小的内存块，并返回一个指向该内存块的指针。示例如下：
`int *dzkjdx = (int *)malloc(10 * sizeof(int)); `
(俺用它分配了一个能够存储10个整数的内存块，并将返回的内存块的地址存储在指针变量dzkjdx中)
- free() 函数用于释放之前使用 malloc()、calloc() 或 realloc() 分配的内存块。示例如下：
 `free(dzkjdx);`
  (用它可以释放之前分配的内存块)  
- 它们主要操作的是堆区     

### 5.为什么要对程序使用的内存进行管理？
 **答：**
  - **避免浪费:**
  如果不管理内存，就可能会分配过多的内存而实际上没有使用，或者频繁地分配和释放小块内存导致内存碎片，使得即使有足够的总内存也无法满足新的内存请求。
  - **提高效率：**
  如果内存管理得当，程序可以更快地找到所需的内存块，从而提高运行效率；
  如果内存管理混乱，程序可能需要花费大量时间来搜索和整理内存，甚至可能因为找不到足够的连续内存而失败。    
  - **防止崩溃：**
 确保每个程序都只能访问和修改它自己的内存区域。 
 - **保持秩序：**
确保内存的使用是安全、可靠和可预测的。  

## 内存模型的应用
|  变量| 区域 | 解释 |  
|:--------:|:--------:|:--------:|  
|constValue  |  全局数据区 | 在main函数上面，是全局变量 |  
| constString  |全局数据区  |在main函数上面，是全局变量 |    
|  globalVar | 全局数据区 |在main函数上面，是全局变量 |
|staticVar|全局数据区 |定义时前面加了个static,使它生命周期贯穿整个程序|
|localVar|栈区 |在function函数内部，是局部变量|
|ptr|栈区 |在function函数内部，是局部变量|
|localVarMain|栈区 |在main函数内部，是局部变量|

 ## 浅谈Cache
 ### 1.什么是冯诺伊曼体系结构？什么是现代计算机的组织结构？这两者的不同点在哪里？
  **答：**
  - 冯·诺依曼计算机由以下几个主要组成部分构成：中央处理器（CPU）、存储器（Memory）、输入/输出设备（I/O Devices）、控制单元（Control Unit）和数据通路（Data Bus）。
  以下为冯诺伊曼体系结构的图示：
 [![pAGZebV.png](https://s21.ax1x.com/2024/10/07/pAGZebV.png)](https://imgse.com/i/pAGZebV)
 - 现代计算机的组织结构主要可以分为五个部分：输入设备、输出设备、存储器、运算器和控制器。
 - **不同点：**
1. **存储器结构**：冯·诺依曼体系结构中，程序指令和数据存储在同一存储器中，而现代计算机的组织结构中，存储器被分为内存和外存，内存主要负责暂时存放CPU中的运算数据，外存则用来长期保存大量的程序和数据。
2. **指令执行方式**：冯·诺依曼体系结构中，指令和数据通过地址进行访问，计算机按照程序存储器中指令的顺序逐条执行指令。现代计算机的组织结构中，运算器和控制器的设计更加复杂，支持并行处理和高速缓存等技术，以提高处理速度。
<font color=orange>（*心得：咋感觉现代计算机的结构本质上还是没跳出冯诺依曼的模型，只是在它的基础上做了一些优化，使它性能提高而已*）</font>
### 2.主存储器是如何工作的？
**答：**
简单来说，它的工作原理就是通过地址线接收CPU发送的地址信号，然后根据该地址信号在存储体中寻找对应的数据进行读取或写入操作。  
<font color=orange>（*心得：网上的资料都讲的好复杂qwq，好难理解qwq*）</font>
### 3.什么是Cache的局部性原理？它包括哪些方面的内容？
**答：**
Cache的局部性原理是计算机存储系统中的一种优化技术，它基于程序访问数据的模式，通过将最近使用或即将使用的数据和指令存储在高速缓存中，来减少对主存的访问次数，从而提高系统的整体性能。该原理主要包括以下两个方面的内容：
**时间局部性：**
Cache会将最近访问过的数据保存在其中，以便当CPU再次需要这些数据时，能够快速地从Cache中获取。
**空间局部性：**
Cache在读取数据时，通常会一次性地读取一个数据块，这个数据块包含了被访问数据及其附近的数据。这样，当CPU需要访问附近的数据时，就可以直接从Cache中获取，而无需再次访问主存。
<font color=orange size=15>（心得：<a href="https://imgse.com/i/pAGnB24"><img src="https://s21.ax1x.com/2024/10/07/pAGnB24.jpg" alt="pAGnB24.jpg" border="0" width=50%/></a>）</font>
### 4.Cache的运用为什么可以加快系统整体性能？
**答：**
因为它有以下功能口牙：
- 减少了数据访问时间
- 提高了数据访问速度
- 降低总线流量
- 减少能耗
- 多级缓存优化
  
## 代码优化
**下图为源代码运行效率的截图：**
[![pAGu3FK.jpg](https://s21.ax1x.com/2024/10/07/pAGu3FK.jpg)](https://imgse.com/i/pAGu3FK)
可能不太能看清楚，它三次运行的耗时分别为0.458s, 0.530s, 0.487s, 平均下来是0.492s
以下是修改后的代码：
```
#include <stdio.h>
#include <stdlib.h>

const int constValue = 100;
const char* constString = "Hello, World!";
int globalVar = 10;
int staticVar = 40; 

void function(int arg) 
{
    int* ptr = malloc(sizeof(int));
    *ptr =30;
    free(ptr);
}

int main() 
{
    int localVar = 50;
    function(localVar);
    return 0;
}
```

**而下图为修改后代码的运行效率截图：**
[![pAGu8JO.jpg](https://s21.ax1x.com/2024/10/07/pAGu8JO.jpg)](https://imgse.com/i/pAGu8JO)
它们分别是0.397s，0.396s，0.395s，平均下来是0.396s，显然少于上述的0.492s
**综上，修改过后的代码确实有所优化**
（ps：实在不清楚怎么测试修改后的鲁棒性有没有提高，只知道运行效率有所改善）
<font color=orange>（心得：小登我确定不了修改的方向，只能一点点地调代码，看看调整前后运行效率有没有提高罢了，好难qwq，事实上也只改了一点点）</font>
<font color=red size=5>总结：虽然这部分的知识可能在大佬的眼里就是渣渣，但零基础の小登还是认真去学习了，完成情况可能不佳，希望改题的giegie能高抬贵手。千山万水总是情，多给一分行不行。</font>